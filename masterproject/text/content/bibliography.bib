@inproceedings{Preproject,
  author   = {Sulebak, Stian J. and Svartveit, Mikkel},
  title    = {Machine Learning for Reverse Engineering &
              Convolutional Neural Networks for Binary Code
              Analysis: A Systematic Literature Review},
  year     = {2024},
  url      = {https://mikkelsvartveit.github.io/thesis/preproject.pdf},
  abstract = {Binary reverse engineering is critical for analyzing security, quality, and compatibility of compiled programs. The increased demand of IoT devices leads to new challenges for reverse engineers, as embedded systems often use custom instruction set architectures (ISA). This systematic literature review examines two key areas in software reverse engineering: machine learning approaches for ISA detection and convolutional neural networks (CNN) for binary code analysis. Through a structured review of 26 primary studies, we analyze how machine learning techniques have been applied to classify ISA features and how CNN have been used for analyzing raw binary code. Our findings reveal that current machine learning approaches for ISA detection predominantly employ traditional models not based on deep learning. They achieve high accuracy in classifying known architectures, but face limitations in distinguishing similar architectures and handling non-code sections of the binary file. For CNN applications to binary code, we find strong evidence of effectiveness particularly in malware classification, with accuracies exceeding 99% on standard datasets without requiring manual feature engineering. However, CNN applications beyond malware detection remain limited. The review identifies significant research gaps, particularly in developing architecture-agnostic methods capable of identifying specific ISA features rather than classifying known architectures. We conclude that while current machine learning methods show promise, future research should focus on leveraging CNN's automatic feature learning capabilities while reducing reliance on binary format metadata.}
}

@inproceedings{Chen2019,
  author    = {Chen, Zhuangyou
               and Pan, Bing
               and Sun, Yanbin},
  editor    = {Sun, Xingming
               and Pan, Zhaoqing
               and Bertino, Elisa},
  title     = {A Survey of Software Reverse Engineering Applications},
  booktitle = {Artificial Intelligence and Security},
  year      = {2019},
  publisher = {Springer International Publishing},
  address   = {Cham},
  pages     = {235--245},
  abstract  = {With the development of software, software maintenance and software security become an important research of software engineering. Software reverse engineering plays an irreplaceable role in software maintenance and software security. In this paper, the applications of software reverse engineering in software maintenance and malware analysis, as well as the legitimacy of software reverse engineering research are briefly discussed, and then software reverse engineering, disassembly, decompilation and so on are introduced. Related technique such as software protection technology, static analysis technology, dynamic analysis technology are described. Then, we discuss the application of software reverse engineering, such as software maintenance, software vulnerability mining, malware analysis and so on. In addition, we also describe how to use software reverse engineering to learn the method of software cracking, so as to resist reverse attack and improve the ability of anti-piracy of software itself.},
  isbn      = {978-3-030-24268-8}
}

@book{Ledin2022,
  title     = {Modern Computer Architecture and Organization: Learn x86, ARM, and RISC-V architectures and the design of smartphones, PCs, and cloud servers},
  author    = {Ledin, Jim and Farley, Dave},
  year      = {2022},
  publisher = {Packt Publishing Ltd}
}

@phdthesis{Spensky2020,
  title  = {Analyzing and Securing Embedded Systems},
  author = {Spensky, Chad},
  year   = {2020},
  school = {UC Santa Barbara}
}

@inproceedings{Kinder2012,
  author    = {Kinder, Johannes},
  booktitle = {2012 19th Working Conference on Reverse Engineering},
  title     = {Towards Static Analysis of Virtualization-Obfuscated Binaries},
  year      = {2012},
  volume    = {},
  number    = {},
  pages     = {61-70},
  abstract  = {Virtualization-obfuscation protects a program from manual or automated analysis by compiling it into byte code for a randomized virtual architecture and attaching a corresponding interpreter. Static analysis appears to be helpless on such programs, where only the code of the interpreter is directly visible. In this paper, we explain the particular challenges for statically analyzing the combination of interpreter and byte code. Static analysis for computing possible variable values is commonly precise only to the program location. In the interpreter loop, however, this combines unrelated data flow information from different locations of the byte code program. To avoid this loss of information, we show how to lift an existing static analysis to an additional dimension of location, to become sensitive to the value of the virtual program counter. Thus, the static analysis merges data flow from equal byte code locations only. We lift an existing analysis implemented in the Jakstab static analyzer and present preliminary results for processing a virtualization-obfuscated binary.},
  keywords  = {Abstracts;Arrays;Transfer functions;Malware;Radiation detectors;Switches;Semantics;reasoning about programs;static analysis;reverse engineering;obfuscation},
  doi       = {10.1109/WCRE.2012.16},
  issn      = {2375-5369},
  month     = {Oct}
}

@inproceedings{Kumari2017,
  author    = {Kumari, Mamta and Hsieh, George and Okonkwo, Christopher A.},
  booktitle = {2017 International Conference on Computational Science and Computational Intelligence (CSCI)},
  title     = {Deep Learning Approach to Malware Multi-class Classification Using Image Processing Techniques},
  year      = {2017},
  volume    = {},
  number    = {},
  pages     = {13-18},
  abstract  = {Malicious software has been growing exponentially during the past years. One of the major challenges for antimalware industry is the vast amounts of data and files which need to be evaluated for potential malicious content. To effectively analyze such large amounts of files, machine learning based malware classification approaches have been developed to classify malware into families based on the same forms of malicious behaviors. This paper presents our design and implementation of a malware classification approach using the Convolutional Neural Networks (CNNs), a prime example of deep learning algorithms. It makes use of CNNs to learn a feature hierarchy for classifying samples of malware binary files, represented as gray-scale images, to their corresponding families. It also uses transfer learning techniques to facilitate model building. Three different models of CNNs were developed and these implemented methods achieved validation accuracy around 97% using the large malware dataset provided for the Microsoft Malware Classification Challenge (BIG 2015).},
  keywords  = {Deep Learning;Convolutional Neural Networks;Transfer Learning;Malware Classification},
  doi       = {10.1109/CSCI.2017.3},
  issn      = {},
  month     = {Dec}
}

@inproceedings{Prima2021,
  author    = {Prima, Bouchaib and Bouhorma, Mohammed},
  title     = {TRANSFER LEARNING AND SMOTE ALGORITHM FOR IMAGE-BASED MALWARE CLASSIFICATION},
  year      = {2021},
  isbn      = {9781450388719},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3454127.3457631},
  doi       = {10.1145/3454127.3457631},
  abstract  = {In recent years, the volume and type of malware is growing, which increases the need of improving a detection and classification malware systems. Nowadays, deep convolutional neural networks (CNNs) have recently proven to be very successful for malware classification due to their performance on images classification. However, their effectiveness is degraded with the unbalanced malware families. In this paper, we propose a malware classification framework using CNN-based deep learning architecture, including a SMOTE technique "Synthetic Minority Oversampling Technique" to balance the dataset (malwares families).Our proposed method consists to converting the binary files into gray scale images and balancing them by the SMOTE method, and then we use them to train the CNN architecture to detect and identify malware families. We use the Transfer Learning technique based on an existing Deep Learning model VGG16 that has previously trained with the ImageNet dataset (≥ 10 million).For evaluations, an extensive experiment was conducted using Microsoft Malware dataset. The Results show that our approach is efficient with an average accuracy of 98\%.},
  booktitle = {Proceedings of the 4th International Conference on Networking, Information Systems \& Security},
  articleno = {56},
  numpages  = {6},
  location  = {KENITRA, AA, Morocco},
  series    = {NISS '21}
}

@article{Hammad2022,
  author         = {Hammad, Baraa Tareq and Jamil, Norziana and Ahmed, Ismail Taha and Zain, Zuhaira Muhammad and Basheer, Shakila},
  title          = {Robust Malware Family Classification Using Effective Features and Classifiers},
  journal        = {Applied Sciences},
  volume         = {12},
  year           = {2022},
  number         = {15},
  article-number = {7877},
  url            = {https://www.mdpi.com/2076-3417/12/15/7877},
  issn           = {2076-3417},
  abstract       = {Malware development has significantly increased recently, posing a serious security risk to both consumers and businesses. Malware developers continually find new ways to circumvent security research’s ongoing efforts to guard against malware attacks. Malware Classification (MC) entails labeling a class of malware to a specific sample, while malware detection merely entails finding malware without identifying which kind of malware it is. There are two main reasons why the most popular MC techniques have a low classification rate. First, Finding and developing accurate features requires highly specialized domain expertise. Second, a data imbalance that makes it challenging to classify and correctly identify malware. Furthermore, the proposed malware classification (MC) method consists of the following five steps: (i) Dataset preparation: 2D malware images are created from the malware binary files; (ii) Visualized Malware Pre-processing: the visual malware images need to be scaled to fit the CNN model’s input size; (iii) Feature extraction: both hand-engineering (Tamura) and deep learning (GoogLeNet) techniques are used to extract the features in this step; (iv) Classification: to perform malware classification, we employed k-Nearest Neighbor (KNN), Support Vector Machines (SVM), and Extreme Learning Machine (ELM). The proposed method is tested on a standard Malimg unbalanced dataset. The accuracy rate of the proposed method was extremely high, making it the most efficient option available. The proposed method’s accuracy rate was outperformed both the Hand-crafted feature and Deep Feature techniques, at 95.42 and 96.84 percent.},
  doi            = {10.3390/app12157877}
}

@article{Al-Masri2024,
  author         = {Al-Masri, Bassam and Bakir, Nader and El-Zaart, Ali and Samrouth, Khouloud},
  title          = {Dual Convolutional Malware Network (DCMN): An Image-Based Malware Classification Using Dual Convolutional Neural Networks},
  journal        = {Electronics},
  volume         = {13},
  year           = {2024},
  number         = {18},
  article-number = {3607},
  url            = {https://www.mdpi.com/2079-9292/13/18/3607},
  issn           = {2079-9292},
  abstract       = {Malware attacks have a cascading effect, causing financial harm, compromising privacy, operations and interrupting. By preventing these attacks, individuals and organizations can safeguard the valuable assets of their operations, and gain more trust. In this paper, we propose a dual convolutional neural network (DCNN) based architecture for malware classification. It consists first of converting malware binary files into 2D grayscale images and then training a customized dual CNN for malware multi-classification. This paper proposes an efficient approach for malware classification using dual CNNs. The model leverages the complementary strengths of a custom structure extraction branch and a pre-trained ResNet-50 model for malware image classification. By combining features extracted from both branches, the model achieved superior performance compared to a single-branch approach.},
  doi            = {10.3390/electronics13183607}
}

@article{El-Shafai2021,
  author         = {El-Shafai, Walid and Almomani, Iman and AlKhayer, Aala},
  title          = {Visualized Malware Multi-Classification Framework Using Fine-Tuned CNN-Based Transfer Learning Models},
  journal        = {Applied Sciences},
  volume         = {11},
  year           = {2021},
  number         = {14},
  article-number = {6446},
  url            = {https://www.mdpi.com/2076-3417/11/14/6446},
  issn           = {2076-3417},
  abstract       = {There is a massive growth in malicious software (Malware) development, which causes substantial security threats to individuals and organizations. Cybersecurity researchers makes continuous efforts to defend against these malware risks. This research aims to exploit the significant advantages of Transfer Learning (TL) and Fine-Tuning (FT) methods to introduce efficient malware detection in the context of imbalanced families without the need to apply complex features extraction or data augmentation processes. Therefore, this paper proposes a visualized malware multi-classification framework to avoid false positives and imbalanced datasets’ challenges through using the fine-tuned convolutional neural network (CNN)-based TL models. The proposed framework comprises eight different FT CNN models including VGG16, AlexNet, DarkNet-53, DenseNet-201, Inception-V3, Places365-GoogleNet, ResNet-50, and MobileNet-V2. First, the binary files of different malware families were transformed into 2D images and then forwarded to the FT CNN models to detect and classify the malware families. The detection and classification performance was examined on a benchmark Malimg imbalanced dataset using different, comprehensive evaluation metrics. The evaluation results prove the FT CNN models’ significance in detecting malware types with high accuracy that reached 99.97% which also outperforms the performance of related machine learning (ML) and deep learning (DL)-based malware multi-classification approaches tested on the same malware dataset.},
  doi            = {10.3390/app11146446}
}

@inproceedings{Alvee2021,
  author    = {Alvee, Syed R. B. and Ahn, Bohyun and Kim, Taesic and Su, Ying and Youn, Young–Woo and Ryu, Myung–Hyo},
  booktitle = {2021 6th IEEE Workshop on the Electronic Grid (eGRID)},
  title     = {Ransomware Attack Modeling and Artificial Intelligence-Based Ransomware Detection for Digital Substations},
  year      = {2021},
  volume    = {},
  number    = {},
  pages     = {01-05},
  abstract  = {Ransomware has become a serious threat to the current computing world, requiring immediate attention to prevent it. Ransomware attacks can also have disruptive impacts on operation of smart grids including digital substations. This paper provides a ransomware attack modeling method targeting disruptive operation of a digital substation and investigates an artificial intelligence (AI)-based ransomware detection approach. The proposed ransomware file detection model is designed by a convolutional neural network (CNN) using 2-D grayscale image files converted from binary files. The experimental results show that the proposed method achieves 96.22% of ransomware detection accuracy.},
  keywords  = {Substations;Conferences;Computational modeling;Gray-scale;Real-time systems;Smart grids;Ransomware;artificial intelligence;attack modeling;convolutional neural network;cybersecurity;digital substation;ransomware},
  doi       = {10.1109/eGRID52793.2021.9662158},
  issn      = {},
  month     = {Nov}
}

@inproceedings{Liang2021,
  author    = {Liang, Junmiao and Ning, Zhenhu and Zhou, Yihua and Cao, Dongzhi},
  booktitle = {2021 6th International Conference on Computational Intelligence and Applications (ICCIA)},
  title     = {Fine-grained Classification of Malicious Code Based on CNN and Multi-resolution Feature Fusion},
  year      = {2021},
  volume    = {},
  number    = {},
  pages     = {123-127},
  abstract  = {With the development of the Internet, security issues in the network have attracted more and more attention. Variants of malicious code are constantly increasing, and their attacks will have a serious impact on the network environment, so effective detection of malicious code has important research significance. However, the current malicious code detection methods still have some problems, such as code detection, cumbersome feature extraction, and misclassification between similar families. To this end, the paper proposes a fine-grained detection method for malicious code. First visualized the binary files of malicious code and converted them into grayscale images. Then, use the improved convolutional neural network to extract the multi-resolution features of grayscale images, and use the interactive fusion method to fuse these features. Finally, input the fused features into the fully connected layer to complete the fine-grained classification of malicious code. Experiments prove that our method is indeed effective for fine-grained classification of malicious code.},
  keywords  = {Visualization;Codes;Fuses;Internet security;Gray-scale;Feature extraction;Malware;malicious code;convolutional neural network;feature fusion;fine-grained classification},
  doi       = {10.1109/ICCIA52886.2021.00031},
  issn      = {},
  month     = {June}
}

@article{Son2022,
  title    = {An enhancement for image-based malware classification using machine learning with low dimension normalized input images},
  journal  = {Journal of Information Security and Applications},
  volume   = {69},
  pages    = {103308},
  year     = {2022},
  issn     = {2214-2126},
  doi      = {https://doi.org/10.1016/j.jisa.2022.103308},
  url      = {https://www.sciencedirect.com/science/article/pii/S2214212622001594},
  author   = {Tran The Son and Chando Lee and Hoa Le-Minh and Nauman Aslam and Vuong Cong Dat},
  keywords = {Image-based Malware Classification, -NN, SVM, CNN, GIST descriptor},
  abstract = {This paper proposes a simple and effective model applied for image-based malware classification using machine learning in which malware images (converted from malware binary files) are directly fed into the classifiers, i.e. k nearest neighbour (k-NN), support vector machine (SVM) and convolution neural networks (CNN). The proposed model does not use the normalized fixed-size square images (e.g. 64 × 64 pixels) or features extracted by image descriptor (e.g. GIST) for training classifiers as existing models do in the literature. Instead, the input images are normalized and horizontally sized down (the width of the image) to a lower dimension of 32 × 64, 16 × 64 or even 8 × 64 than square ones (e.g. 64 × 64 pixels) to reduce the complexity and training time of the model. It is based on the fact that the texture of the malware image is mainly vertically distributed as analysed in this paper. This finding is significant for training those devices which have limited computational resources such as IoT devices. The experiment was conducted on the Malimg, Malheur datasets which contains 9339 (25 malware families) and 3133 variant samples (24 malware families) using k-NN, SVM and CNN classifiers. The achieved results show that it is possible to reduce the dimension of the input images (i.e. 32 × 64, 16 × 64 or even 8 × 64) while still retaining the accuracy of classification as the same as the accuracy obtained by classifier feeding by the fixed-size square image (i.e. 64 × 64 pixels). As a result, training time of the propose model reduces by a half, a quarter, and one-eighth compared to training time taken by the same machine learning-based classifier (i.e. k-NN, SVM and CNN) feeding by fixed-sized square images, i.e. 64 × 64, respectively.}
}

@inproceedings{Yang2019,
  author    = {Yang, Shouguo and Shi, Zhiqiang and Zhang, Guodong and Li, Mingxuan and Ma, Yuan and Sun, Limin},
  booktitle = {ICC 2019 - 2019 IEEE International Conference on Communications (ICC)},
  title     = {Understand Code Style: Efficient CNN-Based Compiler Optimization Recognition System},
  year      = {2019},
  volume    = {},
  number    = {},
  pages     = {1-6},
  abstract  = {Compiler optimization level recognition can be applied to vulnerability discovery and binary analysis. Due to the exists of many different compilation optimization options, the difference in the contents of the binary file is very complicated. There are thousands of compiler optimization algorithms and multiple different processor architectures, so it is very difficult to manually analyze binary files and recognize its compiler optimization level with rules. This paper first proposes a CNN-based compiler optimization level recognition model: BinEye. The system extracts semantic and structural differences and automatically recognize the compiler optimization levels. The model is designed to be very suitable for binary file processing and is easy to understand. We built a dataset containing 80028 binary files for the model training and testing. Our proposed model achieves an accuracy of over 97%. At the same time, BinEye is a fully CNN-based system and it has a faster forward calculation speed, at least 8 times faster than the normal RNN-based model. Through our analysis of the model output, we successfully found the difference in assembly codes caused by the different compiler optimization level. This means that the model we proposed is interpretable. Based on our model, we propose a method to analyze the code differences caused by different compiler optimization levels, which has great guiding significance for analyzing closed source compilers and binary security analysis.},
  keywords  = {Optimization;Security;Convolution;Analytical models;Task analysis;Software;Semantics},
  doi       = {10.1109/ICC.2019.8761073},
  issn      = {1938-1883},
  month     = {May}
}

@article{Pizzolotto2021,
  author   = {Pizzolotto, Davide and Inoue, Katsuro},
  journal  = {IEEE Access},
  title    = {Identifying Compiler and Optimization Level in Binary Code From Multiple Architectures},
  year     = {2021},
  volume   = {9},
  number   = {},
  pages    = {163461-163475},
  abstract = {While compiling a native application, different compiler flags or optimization levels can be configured. This choice depends on the different requirements. For example, if the application binary is intended for final release, the flags and optimization settings should be set for execution speed and efficiency. Alternatively, if the application is to be used for debugging purposes, debug flags should be configured accordingly, usually involving minor or no code optimization. However, this information cannot be easily extracted from a compiled binary. Nonetheless, ensuring the same compiler and compilation flags is particularly important when comparing different binary files, to avoid inaccurate or unreliable analyses. Unfortunately, to understand which flags and optimizations have been used, a deep knowledge of the target architecture and the compiler used is required. In this study, we present two deep learning models used to detect both compiler and optimization level in a compiled binary. The optimization levels we study are O0, O1, O2, O3, and Os in the x86_64, AArch64, RISC-V, SPARC, PowerPC, MIPS, and ARM architectures. In addition, for the x86_64 and AArch64 architectures, we also determine whether the compiler is GCC or Clang. We created a dataset of more than 76000 binaries and used it for training. Our experiments showed over 99.95% accuracy in detecting the compiler and between 92% to 98%, depending on the architecture, in detecting the optimization level. Furthermore, we analyzed the change in accuracy when the amount of data was extremely limited. Our study shows that it is possible to accurately detect both compiler flag settings and optimization levels with function-level granularity.},
  keywords = {Optimization;Codes;Convolutional neural networks;Binary codes;Libraries;Computer architecture;Training;Compilers;deep learning;static code analysis;reverse engineering},
  doi      = {10.1109/ACCESS.2021.3132950},
  issn     = {2169-3536},
  month    = {}
}

@article{Lecun98,
  author   = {Lecun, Y. and Bottou, L. and Bengio, Y. and Haffner, P.},
  journal  = {Proceedings of the IEEE},
  title    = {Gradient-based learning applied to document recognition},
  year     = {1998},
  volume   = {86},
  number   = {11},
  pages    = {2278-2324},
  abstract = {Multilayer neural networks trained with the back-propagation algorithm constitute the best example of a successful gradient based learning technique. Given an appropriate network architecture, gradient-based learning algorithms can be used to synthesize a complex decision surface that can classify high-dimensional patterns, such as handwritten characters, with minimal preprocessing. This paper reviews various methods applied to handwritten character recognition and compares them on a standard handwritten digit recognition task. Convolutional neural networks, which are specifically designed to deal with the variability of 2D shapes, are shown to outperform all other techniques. Real-life document recognition systems are composed of multiple modules including field extraction, segmentation recognition, and language modeling. A new learning paradigm, called graph transformer networks (GTN), allows such multimodule systems to be trained globally using gradient-based methods so as to minimize an overall performance measure. Two systems for online handwriting recognition are described. Experiments demonstrate the advantage of global training, and the flexibility of graph transformer networks. A graph transformer network for reading a bank cheque is also described. It uses convolutional neural network character recognizers combined with global training techniques to provide record accuracy on business and personal cheques. It is deployed commercially and reads several million cheques per day.},
  keywords = {Neural networks;Pattern recognition;Machine learning;Optical character recognition software;Character recognition;Feature extraction;Multi-layer neural network;Optical computing;Hidden Markov models;Principal component analysis},
  doi      = {10.1109/5.726791},
  issn     = {1558-2256},
  month    = {Nov}
}

@misc{Simonyan2015,
  title         = {Very Deep Convolutional Networks for Large-Scale Image Recognition},
  author        = {Karen Simonyan and Andrew Zisserman},
  year          = {2015},
  eprint        = {1409.1556},
  archiveprefix = {arXiv},
  primaryclass  = {cs.CV},
  url           = {https://arxiv.org/abs/1409.1556}
}

@inproceedings{Golik2013,
  author  = {Golik, Pavel and Doetsch, Patrick and Ney, Hermann},
  year    = {2013},
  month   = {08},
  pages   = {1756-1760},
  title   = {Cross-Entropy vs. Squared Error Training: a Theoretical and Experimental Comparison},
  journal = {Proceedings of the Annual Conference of the International Speech Communication Association, INTERSPEECH},
  doi     = {10.21437/Interspeech.2013-436}
}

@misc{Loshchilov2019,
  title         = {Decoupled Weight Decay Regularization},
  author        = {Ilya Loshchilov and Frank Hutter},
  year          = {2019},
  eprint        = {1711.05101},
  archiveprefix = {arXiv},
  primaryclass  = {cs.LG},
  url           = {https://arxiv.org/abs/1711.05101}
}

@conference{Kairajarvi2020,
  author            = {Kairajärvi, Sami and Costin, Andrei and Hämäläinen, Timo},
  title             = {ISAdetect: Usable Automated Detection of CPU Architecture and Endianness for Executable Binary Files and Object Code},
  year              = {2020},
  journal           = {CODASPY 2020 - Proceedings of the 10th ACM Conference on Data and Application Security and Privacy},
  pages             = {376 - 380},
  doi               = {10.1145/3374664.3375742},
  url               = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85083380553&doi=10.1145%2f3374664.3375742&partnerID=40&md5=f0a84cc85f235cc9aa787e3fe10abee2},
  abstract          = {Static and dynamic binary analysis techniques are actively used to reverse engineer software's behavior and to detect its vulnerabilities, even when only the binary code is available for analysis. To avoid analysis errors due to misreading op-codes for a wrong CPU architecture, these analysis tools must precisely identify the Instruction Set Architecture (ISA) of the object code under analysis. The variety of CPU architectures that modern security and reverse engineering tools must support is ever increasing due to massive proliferation of IoT devices and the diversity of firmware and malware targeting those devices. Recent studies concluded that falsely identifying the binary code's ISA caused alone about 10% of failures of IoT firmware analysis. The state of the art approaches detecting ISA for executable object code look promising, and their results demonstrate effectiveness and high-performance. However, they lack the support of publicly available datasets and toolsets, which makes the evaluation, comparison, and improvement of those techniques, datasets, and machine learning models quite challenging (if not impossible). This paper bridges multiple gaps in the field of automated and precise identification of architecture and endianness of binary files and object code. We develop from scratch the toolset and datasets that are lacking in this research space. As such, we contribute a comprehensive collection of open data, open source, and open API web-services. We also attempt experiment reconstruction and cross-validation of effectiveness, efficiency, and results of the state of the art methods. When training and testing classifiers using solely code-sections from executable binary files, all our classifiers performed equally well achieving over 98% accuracy. The results are consistent and comparable with the current state of the art, hence supports the general validity of the algorithms, features, and approaches suggested in those works. © 2020 ACM.},
  type              = {Conference paper},
  publication_stage = {Final},
  source            = {Scopus},
  note              = {Cited by: 4; All Open Access, Green Open Access}
}

@misc{Kairajarvi_dataset2020,
  author       = {Kairajärvi, Sami and Costin, Andrei},
  title        = {ISAdetect binary file and object code dataset},
  howpublished = {\url{http://urn.fi/urn:nbn:fi:att:d58324bd-1cf9-49cf-99cd-5bc2ba781e38}},
  month        = {3},
  year         = {2020},
  note         = {University of Jyväskylä, Informaatioteknologian tiedekunta}
}

@conference{Clemens2015,
  author            = {Clemens, John},
  title             = {Automatic classification of object code using machine learning},
  year              = {2015},
  journal           = {Proceedings of the Digital Forensic Research Conference, DFRWS 2015 USA},
  pages             = {S156 - S162},
  doi               = {10.1016/j.diin.2015.05.007},
  url               = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85054073102&doi=10.1016%2fj.diin.2015.05.007&partnerID=40&md5=0ef7b775f4964200f8dc48479ac27cad},
  abstract          = {Recent research has repeatedly shown that machine learning techniques can be applied to either whole files or file fragments to classify them for analysis. We build upon these techniques to show that for samples of un-labeled compiled computer object code, one can apply the same type of analysis to classify important aspects of the code, such as its target architecture and endianess. We show that using simple byte-value histograms we retain enough information about the opcodes within a sample to classify the target architecture with high accuracy, and then discuss heuristic-based features that exploit information within the operands to determine endianess. We introduce a dataset with over 16000 code samples from 20 architectures and experimentally show that by using our features, classifiers can achieve very high accuracy with relatively small sample sizes. © 2015 The Authors. Published by Elsevier Ltd on behalf of DFRWS.},
  type              = {Conference paper},
  publication_stage = {Final},
  source            = {Scopus},
  note              = {Cited by: 2; All Open Access, Green Open Access, Hybrid Gold Open Access}
}

@article{Nicolao2018,
  author            = {De Nicolao, Pietro and Pogliani, Marcello and Polino, Mario and Carminati, Michele and Quarta, Davide and Zanero, Stefano},
  title             = {ELISA: ELiciting ISA of raw binaries for fine-grained code and data separation},
  year              = {2018},
  journal           = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  volume            = {10885 LNCS},
  pages             = {351 - 371},
  doi               = {10.1007/978-3-319-93411-2_16},
  url               = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85049313640&doi=10.1007%2f978-3-319-93411-2_16&partnerID=40&md5=82ff352427ff57da78df485e9db70903},
  abstract          = {Static binary analysis techniques are widely used to reconstruct the behavior and discover vulnerabilities in software when source code is not available. To avoid errors due to mis-interpreting data as machine instructions (or vice-versa), disassemblers and static analysis tools must precisely infer the boundaries between code and data. However, this information is often not readily available. Worse, compilers may embed small chunks of data inside the code section. Most state of the art approaches to separate code and data are rooted on recursive traversal disassembly, with severe limitations when dealing with indirect control instructions. We propose ELISA, a technique to separate code from data and ease the static analysis of executable files. ELISA leverages supervised sequential learning techniques to locate the code section(s) boundaries of header-less binary files, and to predict the instruction boundaries inside the identified code section. As a preliminary step, if the Instruction Set Architecture (ISA) of the binary is unknown, ELISA leverages a logistic regression model to identify the correct ISA from the file content. We provide a comprehensive evaluation on a dataset of executables compiled for different ISAs, and we show that our method is capable to identify code sections with a byte-level accuracy (F1 score) ranging from 98.13% to over 99.9% depending on the ISA. Fine-grained separation of code from embedded data on x86, x86-64 and ARM executables is accomplished with an accuracy of over 99.9%. © Springer International Publishing AG, part of Springer Nature 2018.},
  type              = {Conference paper},
  publication_stage = {Final},
  source            = {Scopus},
  note              = {Cited by: 9}
}

@conference{Beckman2020,
  author            = {Beckman, Bryan and Haile, Jed},
  title             = {Binary analysis with architecture and code section detection using supervised machine learning},
  year              = {2020},
  journal           = {Proceedings - 2020 IEEE Symposium on Security and Privacy Workshops, SPW 2020},
  pages             = {152 – 156},
  doi               = {10.1109/SPW50608.2020.00041},
  url               = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85099728331&doi=10.1109%2fSPW50608.2020.00041&partnerID=40&md5=8ebd71ce5468e9fdb064a4fce4d84667},
  abstract          = {When presented with an unknown binary, which may or may not be complete, having the ability to determine information about it is critical to future reverse engineering, particularly in discovering the binary's intended use and potential malicious nature. This paper details techniques to both identify the machine architecture of the binary, as well as to locate the important code segments within the file. This identification of unknown binaries makes use of a technique called byte histogram in addition to various machine learning (ML) techniques, which we call 'What is it Binary' or WiiBin. Benefits of byte histograms reflect the simplicity of calculation and do not rely on file headers or metadata, allowing for acceptable results when only a small portion of the original file is available; e.g., when encrypted and/or compressed sections are present in a binary. Utilizing WiiBin, we were able to accurately (>80%) determine the architecture of test binaries with as little as a 20% contagious portion of the file present. We were also able to determine the location of code sections within a binary by utilizing the WiiBin framework. Ultimately, the more information that can be gleaned from a binary file, the easier it is to successfully reverse engineer.  © 2020 IEEE.},
  type              = {Conference paper},
  publication_stage = {Final},
  source            = {Scopus},
  note              = {Cited by: 4; All Open Access, Bronze Open Access, Green Open Access}
}

@conference{Ma2019,
  author            = {Ma, Yuan and Han, Lifang and Ying, Huan and Yang, Shouguo and Zhao, Weiwei and Shi, Zhiqiang},
  title             = {SVM-based instruction set identification for grid device firmware},
  year              = {2019},
  journal           = {Proceedings of 2019 IEEE 8th Joint International Information Technology and Artificial Intelligence Conference, ITAIC 2019},
  pages             = {214 - 218},
  doi               = {10.1109/ITAIC.2019.8785564},
  url               = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85071117472&doi=10.1109%2fITAIC.2019.8785564&partnerID=40&md5=30005f8b19a134fcea0a615531a5f6a2},
  abstract          = {Identifying the binary program instruction set is an important prerequisite for reverse analysis of firmware, but grid device firmware usually lacks a program description header, which poses a serious challenge to instruction set identification. This paper proposes an SVM-based instruction set recognition method(SVM-IBPS). First, the optimal feature list is obtained by the instruction set feature selection method of information gain, and then the SVM-IBPS model is trained by Support Vector Machine and tested in the dataset of 111,918 executable files, which is decompressed and extracted from the embedded device firmware. Finally, a comparative experiment was conducted with Binwalk and SVM-IBPS. The experimental results show that the accuracy of SVM-IBPS on the test dataset is 98.97%, which is 20.7% higher than that of Binwalk, and the time cost is only about one-ninth of it. © 2019 IEEE.},
  type              = {Conference paper},
  publication_stage = {Final},
  source            = {Scopus},
  note              = {Cited by: 2}
}

@article{Sahabandu2023,
  author            = {Sahabandu, Dinuka and Mertoguno, J. Sukarno and Poovendran, Radha},
  title             = {A Natural Language Processing Approach for Instruction Set Architecture Identification},
  year              = {2023},
  journal           = {IEEE Transactions on Information Forensics and Security},
  volume            = {18},
  pages             = {4086 – 4099},
  doi               = {10.1109/TIFS.2023.3288456},
  url               = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85162875813&doi=10.1109%2fTIFS.2023.3288456&partnerID=40&md5=5c848dae3bbf9d2c6e420ce6b9e236f6},
  abstract          = {Binary analysis of software is a critical step in cyber forensics applications such as program vulnerability assessment and malware detection. This involves interpreting instructions executed by software and often necessitates converting the software's binary file data to assembly language. The conversion process requires information about the binary file's target instruction set architecture (ISA). However, ISA information might not be included in binary files due to compilation errors, partial downloads, or adversarial corruption of file metadata. Machine learning (ML) is a promising methodology that can be used to identify the target ISA using binary data in the object code section of binary files. In this paper we propose a binary code feature extraction model to improve the accuracy and scalability of ML-based ISA identification methods. Our feature extraction model can be used in the absence of domain knowledge about the ISAs. Specifically, we adapt models from natural language processing (NLP) to i) identify successive byte patterns commonly observed in binary codes, ii) estimate the significance of each byte pattern to a binary file, and iii) estimate the relevance of each byte pattern in distinguishing between ISAs. We introduce character-level features of encoded binaries to identify fine-grained bit patterns inherent to each ISA. We evaluate our approach using two different datasets: binaries from 12 ISAs and 23 ISAs. Empirical evaluations show that using our byte-level features in ML-based ISA identification results in 98% accuracy compared to the 91% accuracy of state-of-the-art features based on byte-histograms and byte pattern signatures. We observe that character-level features allow reducing the size of the feature set by up to 16x while maintaining accuracy of ISA identification above 97%.  © 2005-2012 IEEE.},
  type              = {Article},
  publication_stage = {Final},
  source            = {Scopus},
  note              = {Cited by: 2; All Open Access, Green Open Access}
}

@article{Andreassen_Morrison_2024,
  title        = {Discovery of endianness and instruction size characteristics in binary programs from unknown instruction set architectures},
  url          = {https://www.ntnu.no/ojs/index.php/nikt/article/view/6225},
  abstractnote = {&lt;p&gt;We approach the problem of streamlining reverse engineering (RE) of binary programs from unknown instruction set architectures (ISA). We focus on two fundamental ISA prerequisites to beginning the RE process: identification of endianness and whether the instruction width is a fixed or variable. For ISAs with a fixed instruction width, we also present methods for estimating the width. In addition to advancing research in software RE, our work can also be seen as a first step in hardware reverse engineering, because endianness and instruction format inherently describe properties of the underlying ISA.&lt;/p&gt; &lt;p&gt;We detail our efforts at feature engineering and perform experiments using a variety of machine learning models on two datasets of architectures using leave-one-group-out-cross-validation to simulate conditions where the tested ISA is unknown and unseen during model training. We use bigram-based features for endianness detection and the autocorrelation function, commonly used in signal processing applications, for differentiation between fixed- and variable-width instruction sizes. Initial results are promising, with endianness detection at 99.4%, fixed- versus variable-width instruction size at 86.0%, and detection of fixed instruction sizes at 88.0%.&lt;/p&gt;},
  number       = {1},
  journal      = {Norsk IKT-konferanse for forskning og utdanning},
  author       = {Andreassen, Joachim and Morrison, Donn},
  year         = {2024},
  month        = {Nov.}
}

@misc{Granboulan_paper2020,
  author    = {Granboulan, Louis},
  title     = {cpu_rec_sstic_english.md},
  year      = {2020},
  month     = {02},
  publisher = {GitHub},
  journal   = {GitHub repository},
  url       = {https://github.com/airbus-seclab/cpu_rec/blob/master/doc/cpu_rec_sstic_english.md},
  commit    = {ccc733093cef9eec3e7d68081ead187ab5ea19bc},
  urldate   = {2025-02-13}
}

@software{singularity,
  author    = {Singularity Developers},
  title     = {Singularity},
  month     = {apr},
  year      = {2021},
  publisher = {Zenodo},
  doi       = {0.5281/zenodo.1310023},
  url       = {https://doi.org/10.5281/zenodo.1310023}
}

@misc{singularity_github,
  author    = {Singularity Developers},
  title     = {Apptainer},
  publisher = {GitHub},
  journal   = {GitHub repository},
  url       = {https://github.com/apptainer/apptainer},
  urldate   = {2025-06-04}
}

@misc{cmake,
  author  = {{Kitware, Inc.}},
  title   = {{CMake - Cross Platform Make}},
  url     = {https://cmake.org/},
  year    = {2025},
  urldate = {2025-06-04}
}

@manual{arm7_datasheet,
  title        = {ARM7 Data Sheet},
  author       = {{Advanced RISC Machines Ltd}},
  organization = {Advanced RISC Machines Ltd},
  number       = {ARM DDI 0020C},
  year         = {1994},
  month        = {dec},
  url          = {https://developer.arm.com/documentation/ddi0027/latest/},
  urldate      = {2025-06-05},
  note         = {Document Number: ARM DDI 0020C. Accessed from Universidad de Valladolid repository}
}

@article{ibm3601964,
  title     = {Architecture of the IBM System/360},
  author    = {Amdahl, Gene M and Blaauw, Gerrit A and Brooks, Frederick P},
  journal   = {IBM Journal of Research and Development},
  volume    = {8},
  number    = {2},
  pages     = {87--101},
  year      = {1964},
  publisher = {IBM}
}

@misc{ibm_system360_history,
  title        = {The IBM System/360},
  author       = {{IBM Corporation}},
  url          = {https://www.ibm.com/history/system-360},
  urldate      = {2025-06-05},
  year         = {2024},
  organization = {IBM Corporation}
}
@misc{ibm_fortran_history,
  title        = {The IBM System/360},
  author       = {{IBM Corporation}},
  url          = {https://www.ibm.com/history/fortran},
  urldate      = {2025-06-05},
  year         = {2024},
  organization = {IBM Corporation}
}

@misc{wikipedia_word_computer_architecture,
  title        = {Word (computer architecture)},
  author       = {{Wikipedia contributors}},
  url          = {https://en.wikipedia.org/wiki/Word_(computer_architecture)},
  urldate      = {2025-06-05},
  year         = {2025},
  organization = {Wikimedia Foundation}
}

@manual{mips2001vol2,
  title        = {MIPS32™ Architecture For Programmers Volume II: The MIPS32™ Instruction Set},
  author       = {{MIPS Technologies, Inc.}},
  organization = {MIPS Technologies, Inc.},
  year         = {2001},
  month        = {March},
  note         = {Document Number: MD00086, Revision 0.95},
  url          = {https://www.cs.cornell.edu/courses/cs3410/2008fa/MIPS_Vol2.pdf},
  urldate      = {2024-12-28}
}

@manual{motorola1994powerpc604,
  title        = {PowerPC 604 RISC Microprocessor Technical Summary},
  author       = {{Motorola Inc. and IBM Microelectronics}},
  organization = {Motorola Inc.},
  year         = {1994},
  month        = {May},
  note         = {Document Number: MPC604/D, IBM Order Number: MPR604TSU-02, Revision 1},
  url          = {https://www.nxp.com/docs/en/data-sheet/MPC604.pdf},
  urldate      = {2024-12-28}
}

@article{ritchie1993,
  title   = {The development of the C language},
  author  = {Ritchie, Dennis M},
  journal = {ACM Sigplan Notices},
  volume  = {28},
  number  = {3},
  pages   = {201--208},
  year    = {1993}
}

@misc{osdev_cross_compiler,
  title        = {Why do I need a Cross Compiler?},
  howpublished = {OSDev Wiki},
  url          = {https://wiki.osdev.org/Why_do_I_need_a_Cross_Compiler%3F},
  urldate      = {2025-06-05},
  author       = {{OSDev contributors}}
}

@misc{cmake_cross_compiling,
  title        = {Cross Compiling With CMake},
  howpublished = {CMake Documentation},
  organization = {Kitware, Inc.},
  url          = {https://cmake.org/cmake/help/book/mastering-cmake/chapter/Cross%20Compiling%20With%20CMake.html},
  urldate      = {2025-06-05}
}

@misc{gcc_wiki_history,
  title        = {A Brief History of GCC},
  howpublished = {GCC Wiki},
  organization = {Free Software Foundation},
  url          = {https://gcc.gnu.org/wiki/History},
  urldate      = {2025-06-05}
}

@misc{gcc_wiki,
  title        = {GCC Wiki},
  howpublished = {GCC Wiki},
  organization = {Free Software Foundation},
  url          = {https://gcc.gnu.org/wiki},
  urldate      = {2025-06-05}
}

@misc{gnu_binutils,
  title        = {GNU Binutils},
  howpublished = {GNU Binutils},
  organization = {Free Software Foundation},
  url          = {https://www.gnu.org/software/binutils/},
  urldate      = {2025-06-05}
}

@misc{Granboulan_cpu_rec_dataset2024,
  author    = {Granboulan, Louis},
  title     = {cpu_rec_corpus},
  publisher = {GitHub},
  journal   = {GitHub repository},
  url       = {https://github.com/airbus-seclab/cpu_rec/tree/master/cpu_rec_corpus},
  commit    = {87f50b1df4125fced3f69e0d93dcfdd6ef70d087},
  urldate   = {2025-02-13}
}

@misc{Mikpe2024,
  author    = {Pettersson, Mikael},
  title     = {buildcross},
  publisher = {GitHub},
  journal   = {GitHub repository},
  url       = {https://github.com/mikpe/buildcross},
  commit    = {c62247a82a6767a3c79f035765bc1b08d1568179},
  urldate   = {2025-02-22}
}

@misc{thesisgithub,
  author    = {Svartveit, Mikkel and Sulebak, Stian},
  title     = {thesis},
  publisher = {GitHub},
  journal   = {GitHub repository},
  url       = {https://github.com/mikkelsvartveit/thesis},
  commit    = {latest},
  urldate   = {2025-06-06}
}

@article{Chikofsky1990,
  author   = {Chikofsky, E.J. and Cross, J.H.},
  journal  = {IEEE Software},
  title    = {Reverse engineering and design recovery: a taxonomy},
  year     = {1990},
  volume   = {7},
  number   = {1},
  pages    = {13-17},
  keywords = {Reverse engineering;Taxonomy;Software maintenance;Hardware;Software systems;Software performance;Water heating;Engineering drawings;Cloning;Control systems},
  doi      = {10.1109/52.43044}
}

@conference{Subedi2018,
  author            = {Subedi, Kul Prasad and Budhathoki, Daya Ram and Dasgupta, Dipankar},
  title             = {Forensic analysis of ransomware families using static and dynamic analysis},
  year              = {2018},
  journal           = {Proceedings - 2018 IEEE Symposium on Security and Privacy Workshops, SPW 2018},
  pages             = {180 - 185},
  doi               = {10.1109/SPW.2018.00033},
  url               = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85052230602&doi=10.1109%2fSPW.2018.00033&partnerID=40&md5=72ed43b76dc28abcb1360c7e24e1b154},
  type              = {Conference paper},
  publication_stage = {Final},
  source            = {Scopus},
  note              = {Cited by: 63; All Open Access, Bronze Open Access}
}

@conference{Fauzi2017,
  author            = {Fauzi, Esa and Hendradjaya, Bayu and Sunindyo, Wikan Danar},
  title             = {Reverse engineering of source code to sequence diagram using abstract syntax tree},
  year              = {2017},
  journal           = {Proceedings of 2016 International Conference on Data and Software Engineering, ICoDSE 2016},
  doi               = {10.1109/ICODSE.2016.7936137},
  url               = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85025681401&doi=10.1109%2fICODSE.2016.7936137&partnerID=40&md5=32b0c33dfb40d33216de615775c6b5b7},
  type              = {Conference paper},
  publication_stage = {Final},
  source            = {Scopus},
  note              = {Cited by: 14}
}

@conference{Ding2019,
  author            = {Ding, Steven H.H. and Fung, Benjamin C.M. and Charland, Philippe},
  title             = {Asm2Vec: Boosting static representation robustness for binary clone search against code obfuscation and compiler optimization},
  year              = {2019},
  journal           = {Proceedings - IEEE Symposium on Security and Privacy},
  volume            = {2019-May},
  pages             = {472 - 489},
  doi               = {10.1109/SP.2019.00003},
  url               = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85063294467&doi=10.1109%2fSP.2019.00003&partnerID=40&md5=b172407cb92b6ee0ce1868cd5698c425},
  type              = {Conference paper},
  publication_stage = {Final},
  source            = {Scopus},
  note              = {Cited by: 330; All Open Access, Bronze Open Access; Resource on obfuscation and use in malware to avoid detection}
}

@conference{Luo2014,
  author            = {Luo, Lannan and Ming, Jiang and Wu, Dinghao and Liu, Peng and Zhu, Sencun},
  title             = {Semantics-based obfuscation-resilient binary code similarity comparison with applications to software plagiarism detection},
  year              = {2014},
  journal           = {Proceedings of the ACM SIGSOFT Symposium on the Foundations of Software Engineering},
  volume            = {16-21-November-2014},
  pages             = {389 - 400},
  doi               = {10.1145/2635868.2635900},
  url               = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84986919852&doi=10.1145%2f2635868.2635900&partnerID=40&md5=3bdcfdb638b3c005c2152722c6efabee},
  type              = {Conference paper},
  publication_stage = {Final},
  source            = {Scopus},
  note              = {Cited by: 188}
}

@article{Qasem2022,
  author            = {Qasem, Abdullah and Shirani, Paria and Debbabi, Mourad and Wang, Lingyu and Lebel, Bernard and Agba, Basile L.},
  title             = {Automatic Vulnerability Detection in Embedded Devices and Firmware: Survey and Layered Taxonomies},
  year              = {2022},
  journal           = {ACM Computing Surveys},
  volume            = {54},
  number            = {2},
  doi               = {10.1145/3432893},
  url               = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85105762241&doi=10.1145%2f3432893&partnerID=40&md5=fbe266e1d3c5a3a1c727d3ca1989ab50},
  type              = {Review},
  publication_stage = {Final},
  source            = {Scopus},
  note              = {Cited by: 40}
}

@conference{Votipka2020,
  author            = {Votipka, Daniel and Rabin, Seth M. and Micinski, Kristopher and Foster, Jeffrey S. and Mazurek, Michelle M.},
  title             = {An observational investigation of reverse engineers' processes},
  year              = {2020},
  journal           = {Proceedings of the 29th USENIX Security Symposium},
  pages             = {1875 - 1892},
  url               = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85091828567&partnerID=40&md5=16d9d8131667a5095d5b391e538b7181},
  type              = {Conference paper},
  publication_stage = {Final},
  source            = {Scopus},
  note              = {Cited by: 48}
}

@article{Muller2009,
  author  = {Müller, Hausi and Kienle, Holger},
  year    = {2009},
  month   = {01},
  pages   = {},
  title   = {A small primer on software reverse engineering},
  journal = {Technical Report, University of Victoria}
}

@inproceedings{Chernov2012,
  title     = {Reverse engineering of binary programs for custom virtual machines},
  author    = {Alexander Chernov and Katerina Troshina},
  booktitle = {ReCon 2012},
  year      = {2012},
  url       = {https://recon.cx/2012/schedule/attachments/40_Chernov-Troshina.pdf}
}

@conference{Popov2007,
  author            = {Popov, Igor V. and Debray, Saumya K. and Andrews, Gregory R.},
  title             = {Binary obfuscation using signals},
  year              = {2007},
  journal           = {16th USENIX Security Symposium},
  pages             = {275 - 290},
  url               = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85045981068&partnerID=40&md5=5ce01c3949e171308aca4aaab5593f72},
  type              = {Conference paper},
  publication_stage = {Final},
  source            = {Scopus},
  note              = {Cited by: 116}
}

@article{Intelx322012,
  author  = {Girkar, M. and Anvin, P. and Lu, H. and Shkurko, D. and Zakharin, V.},
  title   = {The x32 ABI: A New Software Convention for Performance
             on Intel 64 Processors},
  year    = {2012},
  isbn    = {978-1-934053-47-8},
  journal = {Intel Technology Journal},
  volume  = {16},
  issue   = {1},
  pages   = {114 - 128},
  url     = {https://www.intel.com/content/dam/www/public/us/en/documents/research/2012-vol16-iss-1-intel-technology-journal.pdf},
  type    = {Journal article}
}

@misc{Abdelhamid2024,
  title         = {Balancing the Scales: A Comprehensive Study on Tackling Class Imbalance in Binary Classification},
  author        = {Mohamed Abdelhamid and Abhyuday Desai},
  year          = {2024},
  eprint        = {2409.19751},
  archiveprefix = {arXiv},
  primaryclass  = {cs.LG},
  url           = {https://arxiv.org/abs/2409.19751}
}

@misc{MlImbalanced2025,
  title        = {Datasets: Imbalanced datasets},
  author       = {{Google for Developers}},
  howpublished = {\url{https://developers.google.com/machine-learning/crash-course/overfitting/imbalanced-datasets}},
  year         = {2025},
  note         = {Last updated 2025-02-26 UTC},
  organization = {Google},
  urldate      = {2025-05-27}
}

@misc{idapro,
  author  = {Hex-Rays},
  title   = {IDA Pro},
  year    = {2025},
  url     = {https://hex-rays.com/ida-pro/},
  note    = {Commercial disassembler and debugger software, first released in 1991},
  urldate = {2025-02-13}
}
@misc{ghidra,
  author  = {National Security Agency},
  title   = {ghidra},
  year    = {2025},
  url     = {https://ghidra-sre.org/},
  note    = {Open source software reverse engineering framework, first released publicly in 2019},
  urldate = {2025-02-13}
}
@misc{angr,
  author       = {Shoshitaishvili, Yan and Wang, Ruoyu and Hauser, Christophe and Kruegel, Christopher and Vigna, Giovanni},
  title        = {angr},
  year         = {2025},
  url          = {https://angr.io/},
  urldate      = {2025-02-13},
  note         = {Open source binary analysis framework, first released in 2015},
  howpublished = {Available at \url{https://github.com/angr/angr}}
}

@inproceedings{Shoshitaishvili2016,
  title     = {{SoK: (State of) The Art of War: Offensive Techniques in Binary Analysis}},
  author    = {Shoshitaishvili, Yan and Wang, Ruoyu and Salls, Christopher and
               Stephens, Nick and Polino, Mario and Dutcher, Audrey and Grosen, John and
               Feng, Siji and Hauser, Christophe and Kruegel, Christopher and Vigna, Giovanni},
  booktitle = {IEEE Symposium on Security and Privacy},
  year      = {2016}
}
@misc{tigress,
  author    = {Collberg, Christian},
  title     = {the tigress c obfuscator},
  publisher = {University of Arizona},
  year      = {2025},
  url       = {https://tigress.wtf/index.html},
  urldate   = {2025-02-13},
  note      = {Open source binary analysis framework, first released in 2015}
}

@inproceedings{ollvm2015,
  author    = {Pascal Junod and Julien Rinaldini and Johan Wehrli and Julie Michielin},
  booktitle = {Proceedings of the {IEEE/ACM} 1st International Workshop on Software Protection, {SPRO'15}, Firenze, Italy, May 19th, 2015},
  editor    = {Brecht Wyseur},
  publisher = {IEEE},
  title     = {Obfuscator-{LLVM} -- Software Protection for the Masses},
  year      = {2015},
  pages     = {3--9},
  doi       = {10.1109/SPRO.2015.10}
}

@inproceedings{Liang2018,
  title        = {Deobfuscation of virtualization-obfuscated code through symbolic execution and compilation optimization},
  author       = {Liang, Mingyue and Li, Zhoujun and Zeng, Qiang and Fang, Zhejun},
  booktitle    = {Information and Communications Security: 19th International Conference, ICICS 2017, Beijing, China, December 6-8, 2017, Proceedings 19},
  pages        = {313--324},
  year         = {2018},
  organization = {Springer}
}

@article{Costin2018,
  title   = {Iot malware: Comprehensive survey, analysis framework and case studies},
  author  = {Costin, Andrei and Zaddach, Jonas},
  journal = {BlackHat USA},
  volume  = {1},
  number  = {1},
  pages   = {1--9},
  year    = {2018}
}

@article{OrMeir2019,
  author     = {Or-Meir, Ori and Nissim, Nir and Elovici, Yuval and Rokach, Lior},
  title      = {Dynamic Malware Analysis in the Modern Era—A State of the Art Survey},
  year       = {2019},
  issue_date = {September 2020},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {52},
  number     = {5},
  issn       = {0360-0300},
  url        = {https://doi.org/10.1145/3329786},
  doi        = {10.1145/3329786},
  abstract   = {Although malicious software (malware) has been around since the early days of computers, the sophistication and innovation of malware has increased over the years. In particular, the latest crop of ransomware has drawn attention to the dangers of malicious software, which can cause harm to private users as well as corporations, public services (hospitals and transportation systems), governments, and security institutions. To protect these institutions and the public from malware attacks, malicious activity must be detected as early as possible, preferably before it conducts its harmful acts. However, it is not always easy to know what to look for—especially when dealing with new and unknown malware that has never been seen. Analyzing a suspicious file by static or dynamic analysis methods can provide relevant and valuable information regarding a file's impact on the hosting system and help determine whether the file is malicious or not, based on the method's predefined rules. While various techniques (e.g., code obfuscation, dynamic code loading, encryption, and packing) can be used by malware writers to evade static analysis (including signature-based anti-virus tools), dynamic analysis is robust to these techniques and can provide greater understanding regarding the analyzed file and consequently can lead to better detection capabilities. Although dynamic analysis is more robust than static analysis, existing dynamic analysis tools and techniques are imperfect, and there is no single tool that can cover all aspects of malware behavior. The most recent comprehensive survey performed in this area was published in 2012. Since that time, the computing environment has changed dramatically with new types of malware (ransomware, cryptominers), new analysis methods (volatile memory forensics, side-channel analysis), new computing environments (cloud computing, IoT devices), new machine-learning algorithms, and more. The goal of this survey is to provide a comprehensive and up-to-date overview of existing methods used to dynamically analyze malware, which includes a description of each method, its strengths and weaknesses, and its resilience against malware evasion techniques. In addition, we include an overview of prominent studies presenting the usage of machine-learning methods to enhance dynamic malware analysis capabilities aimed at detection, classification, and categorization.},
  journal    = {ACM Comput. Surv.},
  month      = sep,
  articleno  = {88},
  numpages   = {48},
  keywords   = {Dynamic analysis, behavioral analysis, detection, evasion, malware}
}

@unpublished{GorkeSteensland2024,
  author       = {Görke, Norbert Arkadiusz and Steensland, Magnus Hektoen},
  howpublished = {Unpublished work},
  title        = {A Semi-Systematic Review of Reverse Engineering: Processes, Tools, and Their Internal Operations},
  year         = {2024},
  month        = {12}
}

@inproceedings{BinJuice2013,
  author    = {Lakhotia, Arun and Preda, Mila Dalla and Giacobazzi, Roberto},
  title     = {Fast location of similar code fragments using semantic 'juice'},
  year      = {2013},
  isbn      = {9781450318570},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2430553.2430558},
  doi       = {10.1145/2430553.2430558},
  abstract  = {Abstraction of semantics of blocks of a binary is termed as 'juice.' Whereas the denotational semantics summarizes the computation performed by a block, its juice presents a template of the relationships established by the block. BinJuice is a tool for extracting the 'juice' of a binary. It symbolically interprets individual blocks of a binary to extract their semantics: the effect of the block on the program state. The semantics is generalized to juice by replacing register names and literal constants by typed, logical variables. The juice also maintains algebraic constraints between the numeric variables. Thus, this juice forms a semantic template that is expected to be identical regardless of code variations due to register renaming, memory address allocation, and constant replacement. The terms in juice can be canonically ordered using a linear order presented. Thus semantically equivalent (rather, similar) code fragments can be identified by simple structural comparison of their juice, or by comparing their hashes. While BinJuice cannot find all equivalent constructs, for that would solve the Halting Problem, it does significantly improve the state-of-the-art in both the computational complexity as well as the set of equivalences it can establish. Preliminary results show that juice is effective in pairing code variants created by post-compile obfuscating transformations.},
  booktitle = {Proceedings of the 2nd ACM SIGPLAN Program Protection and Reverse Engineering Workshop},
  articleno = {5},
  numpages  = {6},
  location  = {Rome, Italy},
  series    = {PPREW '13}
}

@misc{Mikolov2013,
  title         = {Efficient Estimation of Word Representations in Vector Space},
  author        = {Tomas Mikolov and Kai Chen and Greg Corrado and Jeffrey Dean},
  year          = {2013},
  eprint        = {1301.3781},
  archiveprefix = {arXiv},
  primaryclass  = {cs.CL},
  url           = {https://arxiv.org/abs/1301.3781}
}

@inproceedings{ImageNet,
  author    = {Deng, Jia and Dong, Wei and Socher, Richard and Li, Li-Jia and Kai Li and Li Fei-Fei},
  booktitle = {2009 IEEE Conference on Computer Vision and Pattern Recognition},
  title     = {ImageNet: A large-scale hierarchical image database},
  year      = {2009},
  volume    = {},
  number    = {},
  pages     = {248-255},
  abstract  = {The explosion of image data on the Internet has the potential to foster more sophisticated and robust models and algorithms to index, retrieve, organize and interact with images and multimedia data. But exactly how such data can be harnessed and organized remains a critical problem. We introduce here a new database called “ImageNet”, a large-scale ontology of images built upon the backbone of the WordNet structure. ImageNet aims to populate the majority of the 80,000 synsets of WordNet with an average of 500–1000 clean and full resolution images. This will result in tens of millions of annotated images organized by the semantic hierarchy of WordNet. This paper offers a detailed analysis of ImageNet in its current state: 12 subtrees with 5247 synsets and 3.2 million images in total. We show that ImageNet is much larger in scale and diversity and much more accurate than the current image datasets. Constructing such a large-scale database is a challenging task. We describe the data collection scheme with Amazon Mechanical Turk. Lastly, we illustrate the usefulness of ImageNet through three simple applications in object recognition, image classification and automatic object clustering. We hope that the scale, accuracy, diversity and hierarchical structure of ImageNet can offer unparalleled opportunities to researchers in the computer vision community and beyond.},
  keywords  = {Large-scale systems;Image databases;Explosions;Internet;Robustness;Information retrieval;Image retrieval;Multimedia databases;Ontologies;Spine},
  doi       = {10.1109/CVPR.2009.5206848},
  issn      = {1063-6919},
  month     = {June}
}

@misc{MMCC,
  author       = {Alessandro Panconesi and Marian and Will Cukierski and WWW BIG - Cup Committee},
  title        = {Microsoft Malware Classification Challenge (BIG 2015)},
  year         = {2015},
  howpublished = {\url{https://kaggle.com/competitions/malware-classification}},
  note         = {Kaggle}
}

@inproceedings{Malimg,
  author    = {Nataraj, L. and Karthikeyan, S. and Jacob, G. and Manjunath, B. S.},
  title     = {Malware images: visualization and automatic classification},
  year      = {2011},
  isbn      = {9781450306799},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2016904.2016908},
  doi       = {10.1145/2016904.2016908},
  abstract  = {We propose a simple yet effective method for visualizing and classifying malware using image processing techniques. Malware binaries are visualized as gray-scale images, with the observation that for many malware families, the images belonging to the same family appear very similar in layout and texture. Motivated by this visual similarity, a classification method using standard image features is proposed. Neither disassembly nor code execution is required for classification. Preliminary experimental results are quite promising with 98\% classification accuracy on a malware database of 9,458 samples with 25 different malware families. Our technique also exhibits interesting resilience to popular obfuscation techniques such as section encryption.},
  booktitle = {Proceedings of the 8th International Symposium on Visualization for Cyber Security},
  articleno = {4},
  numpages  = {7},
  keywords  = {computer security, image processing, image texture, malware, malware classification, malware visualization, visualization},
  location  = {Pittsburgh, Pennsylvania, USA},
  series    = {VizSec '11}
}

@inproceedings{Rahul2017,
  author    = {Rahul, R. K.
               and Anjali, T.
               and Menon, Vijay Krishna
               and Soman, K. P.},
  editor    = {Thampi, Sabu M.
               and Mart{\'i}nez P{\'e}rez, Gregorio
               and Westphall, Carlos Becker
               and Hu, Jiankun
               and Fan, Chun I.
               and G{\'o}mez M{\'a}rmol, F{\'e}lix},
  title     = {Deep Learning for Network Flow Analysis and Malware Classification},
  booktitle = {Security in Computing and Communications},
  year      = {2017},
  publisher = {Springer Singapore},
  address   = {Singapore},
  pages     = {226--235},
  abstract  = {In this paper, we present the results obtained by applying deep learning techniques to classification of network protocols and applications using flow features and data signatures. We also present a similar classification of malware using their binary files. We use our own dataset for traffic identification and Microsoft Kaggle dataset for malware classification tasks. The current techniques used in network traffic analysis and malware detection is time consuming and beatable as the precise signatures are known. Deep learned features in both cases are not hand crafted and are learned form data signatures. It cannot be understood by the attacker or the malware in order to fake or hide it and hence cannot be bypassed easily.},
  isbn      = {978-981-10-6898-0}
}

@inproceedings{Yang2018,
  author    = {Yang, Chun and Wen, Yu and Guo, Jianbin and Song, Haitao and Li, Linfeng and Che, Haoyang and Meng, Dan},
  title     = {A Convolutional Neural Network based Classifier for Uncompressed Malware Samples},
  year      = {2018},
  isbn      = {9781450359917},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3267494.3267496},
  doi       = {10.1145/3267494.3267496},
  abstract  = {This paper proposes a deep learning based method for efficient malware classification. Specially, we convert the malware classification problem into the image classification problem, which can be addressed through leveraging convolutional neural networks (CNNs). For many malware families, the images belonging to the same family have similar contours and textures, so we convert the Binary files of malware samples to uncompressed gray-scale images which possess complete information of the original malware without artificial feature extraction. We then design classifier based on Tensorflow framework of Google by combining the deep learning (DL) and malware detection technology. Experimental results show that the uncompressed gray-scale images of the malware are relatively easy to distinguish and the CNN based classifier can achieve a high success rate of 98.2\%},
  booktitle = {Proceedings of the 1st Workshop on Security-Oriented Designs of Computer Architectures and Processors},
  pages     = {15-17},
  numpages  = {3},
  keywords  = {convolutional neural networks (cnns), deep learning (dl), malware classification, tensorflow framework, uncompressed gray-scale images},
  location  = {Toronto, Canada},
  series    = {SecArch'18}
}

@inproceedings{Khan2020,
  author    = {Khan, Mamoona and Baig, Duaa and Khan, Usman Shahid and Karim, Ahmad},
  booktitle = {2020 International Conference on Cyber Warfare and Security (ICCWS)},
  title     = {Malware Classification Framework using Convolutional Neural Network},
  year      = {2020},
  volume    = {},
  number    = {},
  pages     = {1-7},
  abstract  = {Cyber-security is facing a huge threat from malware and malware mass production due to its mutation factors. Classification of malware by their features is necessary for the security of information technology (IT) society. To provide security from malware, deep neural networks (DNN) can offer a superior solution for the detection and categorization of malware samples by using image classification techniques. To strengthen our ideology of malware classification through image recognition, we have experimented by comparing two perspectives of malware classification. The first perspective implements dense neural networks on binary files and the other applies deep layered convolutional neural network on malware images. The proposed model is trained to a set of malware samples, which are further distributed into 9 different families. The dataset of malware samples which is used in this paper is provided by Microsoft for Microsoft Malware Classification Challenge in 2015. The proposed model shows an accuracy of 97.80% on the provided dataset. By using the proposed model optimum classifications results can be attained.},
  keywords  = {Malware;Neural networks;Feature extraction;Deep learning;Hidden Markov models;Biological neural networks;Data models;Malware;deep learning;dense neural network;convolutional neural network},
  doi       = {10.1109/ICCWS48432.2020.9292384},
  issn      = {},
  month     = {Oct}
}

@inproceedings{Sartoli2020,
  author    = {Sartoli, Sara and Wei, Yong and Hampton, Shane},
  booktitle = {2020 19th IEEE International Conference on Machine Learning and Applications (ICMLA)},
  title     = {Malware Classification using Recurrence Plots and Deep Neural Network},
  year      = {2020},
  volume    = {},
  number    = {},
  pages     = {901-906},
  abstract  = {In this paper, we introduce a method for visualizing and classifying malware binaries. A malware binary consists of a series of data points of compiled machine codes that represent programming components. The occurrence and recurrence behavior of these components is determined by the common tasks malware samples in a particular family carry out. Thus, we view a malware binary as a series of emissions generated by an underlying stochastic process and use recurrence plots to transform malware binaries into two-dimensional texture images. We observe that recurrence plot-based malware images have significant visual similarities within the same family and are different from samples in other families. We apply deep CNN classifiers to classify malware samples. The proposed approach does not require creating malware signature or manual feature engineering. Our preliminary experimental results show that the proposed malware representation leads to a higher and more stable accuracy in comparison to directly transforming malware binaries to gray-scale images.},
  keywords  = {Visualization;Transfer learning;Transforms;Programming;Malware;Convolutional neural networks;Task analysis;Malware Classification;Deep Learning;Recurrence Plots;Visualization;Static Analysis},
  doi       = {10.1109/ICMLA51294.2020.00147},
  issn      = {},
  month     = {Dec}
}

@inproceedings{Alam2024,
  author    = {Alam, Inzamamul and Samiullah, Md and Kabir, Upama and Woo, Simon and Leung, Carson K. and Nguyen, Hoang Hai},
  booktitle = {2024 18th International Conference on Ubiquitous Information Management and Communication (IMCOM)},
  title     = {SREMIC: Spatial Relation Extraction-based Malware Image Classification},
  year      = {2024},
  volume    = {},
  number    = {},
  pages     = {1-8},
  abstract  = {Around 800,000 people fall prey to cyberattacks annually, most often by “malware”. Malware has the potential to become a destructive weapon in Cyber-world. It is a difficult task to manually thwart an assault by malware. It is crucial to properly categorize malware binaries in order to identify their origins. Furthermore, malware structure discovery through basic feature extraction approaches are time-consuming and challenging. Malware classification was previously solved using naive machine learning approaches like support vector machine (SVM) and extreme gradient boosting (XGBoost). Recently, deep learning (DL) has shown to be impactful in finding malicious patterns. Without DL, analysis of the vast amounts of available data tends to impossible. Existing methods (e.g., transfer learning, fusion methodology, ensemble learning) may not be effective on actual malware binary files. Moreover, some single image-based malware classification used rudimentary convolutional neural network (CNN) that does not perform well. Faced with these challenges, we propose in this paper a novel model with of a spatial CNN with sufficient regularization and data augmentation that can identify and classify malware in images effectively and efficiently. Our model is evaluated using datasets like MalImg and Microfsoft-Big. The proposed model achieves validation score of 99.93% for MalImg and 99.72% for Microsoft-Big datasets. Our approach outperforms VGG16, VGG19, ResNet50, EfficientNetB1, and Google's Inception v3, including state-of-the-art (SOTA) techniques.},
  keywords  = {Support vector machines;Deep learning;Feature extraction;Malware;Convolutional neural networks;Data mining;Task analysis;Malware classification;Deep learning;Convolutional neural network (CNN);Spatial relation},
  doi       = {10.1109/IMCOM60618.2024.10418339},
  issn      = {},
  month     = {Jan}
}

@inproceedings{Garcia2019,
  author    = {García-Daza-Cervantes, Ixcanil and Reyes-Reyes, Rogelio and Cruz-Ramos, Clara and Ponomaryov, Volodymyr and Ponomaryov, Denys},
  booktitle = {2019 IEEE International Scientific-Practical Conference Problems of Infocommunications, Science and Technology (PIC S&T)},
  title     = {Malware Classification Using Distance and Directional Local Binary Patterns},
  year      = {2019},
  volume    = {},
  number    = {},
  pages     = {397-401},
  abstract  = {Nowadays, malware is one of the biggest cyber threats faced by a common user to a large company, since almost any electronic device is susceptible to an infection due to this type of threat. In addition, malwares continue growing in frequency and sophistication where the identification and classification of the classic and new variants of different malware families is a difficult task that requires modern detection techniques. In this paper, a malware classification method based on two novel local binary pattern descriptors and convolutional neural network, which represents malware binary files as gray-scale images, is presented. The proposed method exploits the fact that most malware variants in the same family have similar local and global structures, therefore, the computing of the local binary descriptors of the gray-scale images facilitates the detection and classification of the variants of a malware. Experimental results have shown that the proposed method outperforms previous related schemes in terms of accuracy resulting in of about 98 %.},
  keywords  = {Malware;Gray-scale;Feature extraction;Convolutional neural networks;Automata;Entropy;Malware classification;Convolutional Neural Network;Local binary patterns;Texture Analysis;visualization},
  doi       = {10.1109/PICST47496.2019.9061336},
  issn      = {},
  month     = {Oct}
}

@inproceedings{Li2021,
  author    = {Li, Xinghua and Li, Xiaolong and Wang, Feng and Li, Wenna and Li, Ang},
  title     = {A Malware Detection Method Based on Machine Learning and Ensemble of Regression Trees},
  year      = {2021},
  isbn      = {9781450390200},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3469213.3470713},
  doi       = {10.1145/3469213.3470713},
  abstract  = {In the context of the current large number of malicious codes, the detection and protection of malicious codes is particularly important. In recent years, a method of using deep learning to detect malicious code has emerged. Thus, in this paper, we propose a new detection method that converts binary files of malicious code into decimal arrays and use 1-D CNN to perform classification and recognition. Aiming at the imbalance in the number of code families, we choose xgboost, which performs well in the classification prediction competition. We conduct experiments on 9,458 malware samples from 25 different malware families in the Vision Research Lab. The experimental results show that our classification prediction reaches 97\% accuracy.},
  booktitle = {2021 2nd International Conference on Artificial Intelligence and Information Systems},
  articleno = {280},
  numpages  = {6},
  keywords  = {Cnn, deep learning, malware, xgboost},
  location  = {Chongqing, China},
  series    = {ICAIIS 2021}
}

@article{Parihar2022,
  abstract      = {Malware classification continues to be exceedingly difficult due to the exponential growth in the number and variants of malicious files. It is crucial to classify malicious files based on their intent, activity, and threat to have a robust malware protection and post-attack recovery system in place. This paper proposes a novel deep learning-based model, S-DCNN, to classify malware binary files into their respective malware families efficiently. S-DCNN uses the image-based representation of the malware binaries and leverages the concepts of transfer learning and ensemble learning. The model incorporates three deep convolutional neural networks, namely ResNet50, Xception, and EfficientNet-B4. The ensemble technique is used to combine these component models'predictions and a multilayered perceptron is used as a meta classifier. The ensemble technique fuses the diverse knowledge of the component models, resulting in high generalizability and low variance of the S-DCNN. Further, it eliminates the use of feature engineering, reverse engineering, disassembly, and other domain-specific techniques earlier used for malware classification. To establish S-DCNN's robustness and generalizability, the performance of proposed model is evaluated on the Malimg dataset, a dataset collected from VirusShare, and packed malware dataset counterparts of both Malimg and VirusShare datasets. The proposed method achieves a state-of-the-art 10-fold accuracy of 99.43{\%} on the Malimg dataset and an accuracy of 99.65{\%} on the VirusShare dataset.},
  author        = {Parihar, Anil Singh and Kumar, Shashank and Khosla, Savya},
  date          = {2022/09/01},
  date-added    = {2024-10-29 16:44:56 +0100},
  date-modified = {2024-10-29 16:44:56 +0100},
  doi           = {10.1007/s11042-022-12615-7},
  id            = {Parihar2022},
  isbn          = {1573-7721},
  journal       = {Multimedia Tools and Applications},
  number        = {21},
  pages         = {30997--31015},
  title         = {S-DCNN: stacked deep convolutional neural networks for malware classification},
  url           = {https://doi.org/10.1007/s11042-022-12615-7},
  volume        = {81},
  year          = {2022},
  bdsk-url-1    = {https://doi.org/10.1007/s11042-022-12615-7}
}

@misc{Idun,
  author       = {NTNU},
  title        = {Idun – High Performance Computing},
  howpublished = {\url{https://www.hpc.ntnu.no/idun/}},
  note         = {Accessed: 2025-03-07}
}

@misc{ResNet,
  title         = {Deep Residual Learning for Image Recognition},
  author        = {Kaiming He and Xiangyu Zhang and Shaoqing Ren and Jian Sun},
  year          = {2015},
  eprint        = {1512.03385},
  archiveprefix = {arXiv},
  primaryclass  = {cs.CV},
  url           = {https://arxiv.org/abs/1512.03385}
}

@misc{MLPClassifierScikitLearn,
  author  = {{scikit-learn}},
  title   = {MLPClassifier — scikit-learn 1.6.1 documentation},
  url     = {https://scikit-learn.org/stable/modules/generated/sklearn.neural_network.MLPClassifier.html},
  year    = {2025},
  urldate = {2025-05-15}
}

@misc{UN2015,
  author = {{United Nations General Assembly}},
  title  = {Transforming our world: the 2030 Agenda for Sustainable Development},
  year   = {2015},
  url    = {https://sdgs.un.org/2030agenda},
  note   = {Resolution A/RES/70/1. Adopted on 25 September 2015}
}

@article{DeVries2023,
  title    = {The growing energy footprint of artificial intelligence},
  journal  = {Joule},
  volume   = {7},
  number   = {10},
  pages    = {2191-2194},
  year     = {2023},
  issn     = {2542-4351},
  doi      = {https://doi.org/10.1016/j.joule.2023.09.004},
  url      = {https://www.sciencedirect.com/science/article/pii/S2542435123003653},
  author   = {Alex {de Vries}},
  abstract = {Alex de Vries is a PhD candidate at the VU Amsterdam School of Business and Economics and the founder of Digiconomist, a research company dedicated to exposing the unintended consequences of digital trends. His research focuses on the environmental impact of emerging technologies and has played a major role in the global discussion regarding the sustainability of blockchain technology.}
}

@article{IBMs390x2002,
  author   = {Plambeck, K. E. and Eckert, W. and Rogers, R. R. and Webb, C. F.},
  journal  = {IBM Journal of Research and Development},
  title    = {Development and attributes of z/Architecture},
  year     = {2002},
  volume   = {46},
  number   = {4.5},
  pages    = {367-379},
  keywords = {},
  doi      = {10.1147/rd.464.0367}
}

--- Buildcross libraries

@misc{freetype,
  author  = {FreeType Project},
  title   = {FreeType},
  year    = {2025},
  url     = {https://www.freetype.org/},
  note    = {Open source software library to render fonts, first released in 1996},
  urldate = {2025-02-13}
}

@misc{freetypesource,
  author  = {FreeType Project},
  title   = {FreeType Source Code},
  year    = {2025},
  url     = {https://gitlab.freedesktop.org/freetype/freetype},
  note    = {Source code for FreeType version 2.13.3, first released in 1996},
  urldate = {2025-02-13}
}

@misc{libgit2,
  author  = {libgit2 contributors},
  title   = {libgit2},
  year    = {2025},
  url     = {https://libgit2.org/},
  note    = {Open source library for Git operations, first released in 2013},
  urldate = {2025-02-13}
}
@misc{libgit2source,
  author  = {libgit2 contributors},
  title   = {libgit2 Source Code},
  year    = {2025},
  url     = {https://github.com/libgit2/libgit2},
  note    = {Source code for libgit2 version 1.9.0, first released in 2013},
  urldate = {2025-02-13}
}

@misc{libjpeg-turbo,
  author  = {libjpeg-turbo Project},
  title   = {libjpeg-turbo},
  year    = {2025},
  url     = {https://libjpeg-turbo.org/},
  note    = {Open source library for JPEG image compression and decompression, first released in 2010},
  urldate = {2025-02-13}
}
@misc{libjpeg-turbosource,
  author  = {libjpeg-turbo Project},
  title   = {libjpeg-turbo Source Code},
  year    = {2025},
  url     = {https://github.com/libjpeg-turbo/libjpeg-turbo},
  note    = {Source code for libjpeg-turbo version 3.1.0, first released in 2010},
  urldate = {2025-02-13}
}

@misc{libpng,
  author  = {The PNG Development Group},
  title   = {libpng},
  year    = {2025},
  url     = {http://www.libpng.org/pub/png/libpng.html},
  note    = {Open source library for PNG image processing, first released in 1995},
  urldate = {2025-02-13}
}

@misc{libpngsource,
  author  = {The PNG Development Group},
  title   = {libpng Source Code},
  year    = {2025},
  url     = {https://github.com/pnggroup/libpng},
  note    = {Source code for libpng version 1.6.47, first released in 1995},
  urldate = {2025-02-13}
}

@misc{libwebp,
  author  = {Google Inc.},
  title   = {libwebp},
  year    = {2025},
  url     = {https://developers.google.com/speed/webp},
  note    = {Open source library for WebP image format, first released in 2010},
  urldate = {2025-02-13}
}

@misc{libwebpsource,
  author  = {Google Inc.},
  title   = {libwebp Source Code},
  year    = {2025},
  url     = {https://chromium.googlesource.com/webm/libwebp/},
  note    = {Source code for libwebp version 1.5.0, first released in 2010},
  urldate = {2025-02-13}
}

@misc{libyaml,
  author  = {Kirill Simonov and Ingy döt Net},
  title   = {LibYAML},
  year    = {2025},
  url     = {https://pyyaml.org/wiki/LibYAML},
  note    = {Open source C library for YAML parsing and emitting, first released in 2006},
  urldate = {2025-02-13}
}

@misc{libyamlsource,
  author  = {Kirill Simonov and Ingy döt Net},
  title   = {LibYAML Source Code},
  year    = {2025},
  url     = {https://github.com/yaml/libyaml},
  note    = {Source code for libyaml version 0.2.5, first released in 2006},
  urldate = {2025-02-13}
}

@misc{pcre2,
  author  = {Philip Hazel and University of Cambridge},
  title   = {PCRE2},
  year    = {2025},
  url     = {https://www.pcre.org/},
  note    = {Open source Perl Compatible Regular Expressions library, first released in 2015},
  urldate = {2025-02-13}
}

@misc{pcre2source,
  author  = {Philip Hazel and University of Cambridge},
  title   = {PCRE2 Source Code},
  year    = {2025},
  url     = {https://github.com/PCRE2Project/pcre2},
  note    = {Source code for PCRE2 version 10.45, first released in 2015},
  urldate = {2025-02-13}
}

@misc{xzutils,
  author  = {Lasse Collin and xz-utils contributors},
  title   = {XZ Utils},
  year    = {2025},
  url     = {https://tukaani.org/xz/},
  note    = {Open source data compression software using LZMA algorithm, first released in 2009},
  urldate = {2025-02-13}
}

@misc{xzutilssource,
  author  = {Lasse Collin and xz-utils authors and contributors},
  title   = {XZ Utils Source Code},
  year    = {2025},
  url     = {https://git.tukaani.org/?p=xz.git},
  note    = {Source code for XZ Utils, first released in 2009},
  urldate = {2025-02-13}
}

@misc{zlib,
  author  = {Greg Roelof and Jean-loup Gailly and Mark Adler},
  title   = {zlib},
  year    = {2025},
  url     = {https://www.zlib.net/},
  note    = {Open source software library for data compression, first released in 1995},
  urldate = {2025-02-13}
}

@misc{zlibsource,
  author  = {Jean-loup Gailly and Mark Adler},
  title   = {zlib Source Code},
  year    = {2025},
  url     = {https://github.com/madler/zlib},
  note    = {Source code for zlib version 1.3, first released in 1995},
  urldate = {2025-02-13}
}

@misc{U-Net,
  title         = {U-Net: Convolutional Networks for Biomedical Image Segmentation},
  author        = {Olaf Ronneberger and Philipp Fischer and Thomas Brox},
  year          = {2015},
  eprint        = {1505.04597},
  archiveprefix = {arXiv},
  primaryclass  = {cs.CV},
  url           = {https://arxiv.org/abs/1505.04597}
}