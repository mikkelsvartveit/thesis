\acresetall

# Conclusion

In this thesis, we have investigated the application of \acp{CNN} for detecting \ac{ISA} features from raw binary code, to address the challenge of reverse engineering binaries from unknown or undocumented architectures. Our work has explored a new direction compared to prior literature, leveraging deep learning models' ability to automatically extract meaningful patterns from the input rather than relying on manual feature engineering.

RQ1 aimed to identify which \ac{ISA} features were suitable for detection through \ac{CNN}-based approaches. Our experiments showed that for our two tested target features – endianness and instruction width type – the models performed similarly for both features. Using \ac{LOGO CV} on the ISAdetect dataset, we observed accuracies up to 90.3% and 88.0% for endianness and instruction width type classification, respectively. When we extended the evaluation with more datasets, we saw that accuracy for both target features dropped to less than 75% on previously unseen architectures. While we observed a notable decline in performance when evaluating on a large set of unseen \acp{ISA}, we do note that the model performance was on par with prior research that relied on carefully engineered features.

RQ2 asked whether the way we encoded the binary files for the \ac{CNN} input layer impacts the \acp{CNN}' ability to learn \ac{ISA} characteristics. Our results revealed that while both one-dimensional and two-dimensional encodings proved viable, neither was consistently better in all scenarios. For endianness detection, the dimensionality of the encoding appeared to have minimal impact, likely because endianness patterns manifest at the byte level regardless of spatial arrangement. Instruction width type detection showed slightly higher accuracies with two-dimensional encodings in some experiments, possibly due to the repeating patterns in some fixed-width instruction sets. However, the performance difference was not large enough to claim a statistically significant advantage for two-dimensional encodings.

RQ3, which explored different \ac{CNN} architectures and compared their performance, led us to conclude that large models with many parameters do not exhibit better performance than smaller models for this task. We saw that in nearly all experiments, the small models with less than 150,000 trainable parameters performed on par or better than the large ResNet-50 model with 23.5 million parameters. Additionally, we observed that embedding layers seemed to have a positive effect. In many experiments, particularly for endianness detection, the embedding-augmented models showed statistically significant performance improvements over their non-embedding counterparts.

In conclusion, our work has shown that \ac{CNN}-based approaches to detecting individual \ac{ISA} features perform on par with, but not significantly better than, existing approaches in prior research. However, there is value in the automatic feature engineering characteristics of deep learning models over the traditional machine learning approaches due to the elimination of extensive feature engineering efforts. Through this thesis, we have demonstrated that very small \acp{CNN} work just as well as larger ones for this particular task, and have also demonstrated the effectiveness of embedding layers when applying deep learning techniques to binary code analysis. Lastly, our research has highlighted the importance of high-quality, well-labeled datasets for deep learning applications in binary reverse engineering, and the development of the BuildCross dataset has not only enhanced our own research capabilities but will also provide a valuable resource for future work in this field.

## Future work

We identify several possibilities for building on our work. Firstly, extending our approach to more target features would allow for a deeper understanding of the binary file. Considering that \ac{CNN}-based models do not demand extensive feature engineering, applying the same methodology for other \ac{ISA} features, such as word size, instruction width (for fixed-width instruction sets), or register count, would be feasible given a dataset with clearly defined labels.

Furthermore, extending our approach to operate on full binary files, rather than just code sections, would be beneficial. This would enable our method to be applied even when the code section of a binary cannot be easily identified. To achieve this, we propose adopting a "rolling window" technique, as demonstrated in a previous binary analysis study by Beckman & Haile [@Beckman2020].

We also reason that there are more applications for which \acp{CNN} can be applied to binary analysis. The application of \acp{CNN} to closed-set \ac{ISA} detection is a convincing direction for future research, building upon prior work in this area (see \autoref{machine-learning-for-isa-detection}). In our experiments, we observed that \ac{CNN} models tended to overfit on \ac{ISA}-specific characteristics. While causing poor generalizability when detecting individual features from an unseen \ac{ISA}, this tendency could be favorable for classifying a binary's \ac{ISA} from a known set. Our initial investigation suggests that the model architectures used in this thesis can be effectively repurposed for full \ac{ISA} detection, demonstrating high accuracy in this task. Using a \ac{CNN} model trained on both ISAdetect and the diverse BuildCross dataset developed in this thesis, there is potential for advancing the state of the art in \ac{ISA} detection.

Another potential application of \acp{CNN} is automatic identification of code sections within raw binary files. Usually, the reverse engineering process requires knowing which parts of the binary file actually contain CPU instructions. Techniques from image segmentation, such as the U-Net architecture, could be adapted for this purpose [@U-Net]. A one-dimensional CNN capable of segmentation could be trained to predict a segmentation mask, highlighting the regions of the binary file corresponding to executable code.

Finally, further work could be carried out to extend our custom dataset. BuildCross was created to address the gaps in ISAdetect and CpuRec, with architectures deliberately chosen to avoid overlap with ISAdetect. While this design decision was based on the requirements of this thesis, BuildCross could be expanded for future research. The dataset could incorporate well-established architectures such as ARM, MIPS, PowerPC, and x86 to provide broader coverage of mainstream instruction sets. Additionally, numerous uncommon architectures supported by previous versions of the \ac{GCC} toolchain were excluded due to time constraints. These could be added to create an even more comprehensive and robust dataset for future binary analysis research.
